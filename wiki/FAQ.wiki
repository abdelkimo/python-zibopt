#summary If anyone were asking questions, they'd probably be asking these...
#labels Featured

= Frequently Asked Questions =
==== Q: How do I change priorities of branching rules and set other settings? ====

A: On instantiation, a SCIP solver is preloaded with dictionaries containing available branching rules, conflict handlers, heuristics, presolvers, heuristics, presolvers, domain propagators, and node selectors.  You can set properties such as priority and frequency on these directly.  See the module docs for complete examples:
{{{
solver.branching['fullstrong'].priority = 10
}}}

==== Q: What's IMPLINT? ====

A: This type is for variables that are supposed to take on integer values, but will do so implicitly since they only appear in constraints with other integer variables.  This can save SCIP some time.

==== Q: I can't represent my problem in its entirety and need to solve a combinatorial relaxation before adding more constraints.  How can I do this? ====

A: SCIP keeps the original problem untouched and works against a transformed copy of problem.  Once you've solved by calling solver.minimize() or solver.maximize(), you can make changes to the original problem by first calling solver.restart().
{{{
# ... instantiate a problem ...
solver.maximize()
new_variable   = solver.variable(coefficient=1)
new_constraint = solver.constraint(upper=2, coefficients={new_variable: 1})
solver.maximize()
}}}

==== Q: I know a good solution already.  How do I tell the solver about it? ====

A: solver.minimize() and solver.maximize() both take in an optional solution dictionary mapping variable instances to their primal values.  If this is done, the solution is checked for feasibility and a SolverError is raised in case of infeasibility.

==== Q: How do I see what SCIP is doing? ====

A: solver.minimize() and solver.maximize() also take an optional quiet argument, which defaults to true.  If you pass quiet=False to minimize or maximize, then you'll see the normal SCIP chatter:
{{{
solver.maximize(quiet=False)
}}}

==== Q: There seem to be multiple ways to add constraints and objectives.  What should I use? ====

A: This may be best served by an example.  These two programs are equivalent.  First, we show the algebraic method:
{{{
from zibopt import scip
solver = scip.solver()

x1 = solver.variable(scip.INTEGER)
x2 = solver.variable(scip.INTEGER)
x3 = solver.variable(scip.INTEGER)

solver += x1 <= 2
solver += x1 + x2 + 3*x3 <= 3

solution = solver.maximize(objective=x1 + x2 + 2*x3)
}}}
What this really does behind the scenes is:
{{{
from zibopt import scip
solver = scip.solver()

x1 = solver.variable(coefficient=1, vartype=scip.INTEGER, upper=2)
x2 = solver.variable(coefficient=1, vartype=scip.INTEGER)
x3 = solver.variable(coefficient=2, vartype=scip.INTEGER)

solver.constraint(upper=3, coefficients={x1:1, x2:1, x3:3})

solution = solver.maximize()
}}}
The former example overrides += on the solver to add constraints.  Valid constraints must have the form l <= some expression <= u, where the expression contains references to SCIP variables and l and u are constants for lower and upper bounds, respectively.  One or both of the bounds may be used.

The syntax plays nicely with the Python builtin sum(...), example of which can be found in the source.

==== Q: How can I set branching priority on a variable? ====

A: Variables expose a priority attribute.  You can access that directly or pass in the priority to solver.variable(...):
{{{
x = solver.variable(scip.INTEGER)
x.priority = 1000

x = solver.variable(scip.INTEGER, priority=10)
}}}
This uses SCIP's SCIPvarChgBranchPriority function for setting the branching priority.  Depending on the state of the solver, what may actually get set is the priority on a transformed or aggregate variable, meaning that the value of x.priority may not look how you expect.

